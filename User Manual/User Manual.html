<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>User Manual</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<header id="title-block-header">
<h1 class="title">User Manual</h1>
</header>
<h2>DM42 Calculator Compiler</h2>
<h3>Introduction</h3>
<p>This compiler translates high-level language programs into keystrokes
for the DM42 calculator. These programs will run on unmodified DM42
calculators – no firmware flashing required. Most programs will also run
on the Free42 emulator provided they do not use any unsupported DM42
extensions. Compiled programs make use of the DM42's extended stack mode
(NSTK). "Dynamic Stack Extension" should be enabled in the calculator's
settings.</p>
<h3>Examples</h3>
<p>The following examples illustrate the high-level language
supported.</p>
<pre class="scroll">
program gcd()
{
  var a = 36;
  var b = 24;
  while (a != b)
    if (a &gt; b) a = a - b;
    else       b = b – a;
  return a;
}
</pre>
<p>Computes the greatest common divisor (gcd) of two numbers using
Euclid's algorithm. The result is returned on the calculator's
stack.</p>
<pre class="scroll">
program gcd_as_function()
{
  var a = 36;
  var b = 24;
  func gcd()
  {
    while (a != b)
      if (a &gt; b) a = a - b; 
      else       b = b - a;
    return a;
  }
  return gcd();
}
</pre>
<p>Here gcd is defined as a function, which is then called by the main
program.</p>
<pre class="scroll">
program lcm_with_parameters(a, b)
{
  func gcd(x, y)
  {
    while (x != y)
      if (x &gt; y) x = x - y; 
      else       y = y - x;
    return x;
  }
  func lcm(x, y)
  {
    return x * (y / gcd(x, y));
  }
  return lcm(a, b);
}
</pre>
<p>In this example gcd is defined as a function with two parameters,
which is then used by another function computing the lowest common
multiple (lcm) of two values. Here the main program itself has
parameters which are taken from the calculator's stack when the program
is executed.</p>
<p>Programs can consume and return complex numbers...</p>
<pre class="scroll">
program complex_test(a, b)
{
  return complex(a^2, sin(b));
}
</pre>
<p>...and provide an easy way to define and manipulate matrices.</p>
<pre class="scroll">
program matrix_test(a, b, c)
{
  var m1 = matrix(
                  [a^2, 1,   1  ], 
                  [1,   b^2, 1  ], 
                  [1,   1,   c^2]
                 );
  var m2 = matrix(
                  [1,  1,    c^3], 
                  [1,   b^3, 1  ], 
                  [a^3, 1,   1  ]
                 );
  return determinant(transpose(m1 * m2));
}
</pre>
<p>Finally, here is a program to plot a graph of a function on the
calculator's screen.</p>
<pre class="scroll">
program plotter()
{
  var x_max = recall(&quot;ResX&quot;) - 1;
  var y_max = recall(&quot;ResY&quot;) - 1;
  
  func f(x)
  {
   return (y_max / 2) * sin(8 * x);
  }
  
  func void plot()
  {
    var x0 = x_max / 2;
    var y0 = y_max / 2;
    v_line(x0);
    h_line(y0);
    for x = 0 to x_max do
    {
      var y = f(x - x0) + y0;
      if (y &lt;= y_max) pixel(y_max - y, x);
    }
  } 
  degrees();
  plot();
}
</pre>
<p>The recall function recalls named variables from the calculator. In
this case the “virtual variables” which contain the screen
resolution.</p>
<h3>Keystroke Output</h3>
<p>The output of the compiler is a textual version of the keystrokes
defining a calculator program. A straightforward way of converting this
to a raw file for uploading on to a DM42 calculator is to copy the
entire text and then paste it into a new program using the Free42
program. The Free42 export option in the file menu can then be used to
generate a raw file. Free42 will also directly run most of the programs
generated by the compiler and can be used for testing before uploading
to a real DM42.</p>
<p>The following example is the keystroke output produced by compiling
the simple gcd example program shown above.</p>
<div class="columns3">
<p>LBL &quot;gcd&quot;</p>
<p>NSTK</p>
<p>36</p>
<p>STO 01</p>
<p>DROP</p>
<p>24</p>
<p>STO 02</p>
<p>DROP</p>
<p>LBL 01</p>
<p>RCL 01</p>
<p>RCL 02</p>
<p>-</p>
<p>X=0?</p>
<p>GTO 00</p>
<p>DROP</p>
<p>RCL 01</p>
<p>RCL 02</p>
<p>-</p>
<p>X&lt;=0?</p>
<p>GTO 03</p>
<p>DROP</p>
<p>RCL 01</p>
<p>RCL 02</p>
<p>-</p>
<p>STO 01</p>
<p>DROP</p>
<p>GTO 02</p>
<p>LBL 03</p>
<p>DROP</p>
<p>RCL 02</p>
<p>RCL 01</p>
<p>-</p>
<p>STO 02</p>
<p>DROP</p>
<p>LBL 02</p>
<p>GTO 01</p>
<p>LBL 00</p>
<p>DROP</p>
</div>
<h3>User Interface</h3>
<p>The compiler's user interface allows high-level language programs to
be opened and saved to and from text files, or to be entered and edited
using a primitive text editor. Four tabs on the right of the compiler
window show the keystoke output after the source has been compiled, an
EBF representation of the syntax of the high-level language, information
about the compiled program, e.g. register usage and the correspondence
between high-level program variables and registers, and a set of
compilation options.</p>
<img src="figure_1.jpg">
<p>For the gcd program the information tab would appear as
followings.</p>
<img src="figure_2.jpg">
<p>The options tab shows the following options along with their
explanations.</p>
<img src="figure_3.jpg">
<ol type="1">
<h3>High-Level Language Variables, Functions and
Statements</h3>
<p>The language uses a relatively conventional “C-like” syntax and is
dynamically typed, i.e. the calculator will produce error messages if
inappropriate operations are performed on values. Programs have names
which are used to define the labels for accessing them. These must
conform with the maximum number of characters the calculator allows for
labels. Programs may also have named parameters. These are either copied
from the calculator's stack when program execution begins, or can be
prompted for using INPUT commands. See the option tab above.</p>
<p>Programs can also have local variables, which must be defined before
any functions or statements, and which must be initialised. Identifiers
are case sensitive. Functions can also have local variables and contain
nested function definitions. Functions can access program variables and
program functions unless their names have been redefined locally. All
variables and functions must be defined before they are used. Functions
may not be called recursively. This restriction allows all variables to
be statically associated with numbered calculator registers.</p>
<p>Functions usually return a single value and do so using a mandatory
return statement. Control is returned to the calling function or program
when a return statement is executed (The calculator's restrictions on
the depth on nested calls apply). However, programs may return more than
one value, each one being pushed onto the calculator's stack as return
statements are executed. A program only terminates after its final
statement has been executed. If the keyword “void” occurs before a
function name, that function cannot return a result or be called in an
expression. Functions with no parameters must be followed by an empty
pair of brackets to distinguish them from variables, e.g. pi().</p>
<p>The control statements provided are if-then-else statements, while
statements and for statements. The conditions allowed in if-then-else
statements and while statements are simple comparisons between two
expressions. For statements may specify an optional step, and the
controlled variable specified is declared automatically.</p>
<p>Anywhere a single statement is allowed, a block of statements
enclosed in braces and possibly containing declarations, is allowed.
There is an empty statement written as “skip”. Statements corresponding
to the INPUT, PROMPT, STOP and VIEW commands are also available.</p>
<pre class="scroll">
skip;
input(my_variable);
prompt(“My Message”);
stop;
view(my_variable);
</pre>
<h3>High-Level Expressions</h3>
<p>Expressions follow the usual precedence rules for the standard
operators +, -, | (or), xor, *, /, % (modulus), &amp; (and), ^ (raise to
the power), ! (not). Functions defined in programs may be called in
expressions provided they are not declared using the void keyword. In
addition, a wide range of the functions provided by the calculator are
also available. These include the trig functions, complex functions,
matrix functions, time and date functions etc. This set of functions is
extensible by editing the “standard.ini” file stored in the same
location as the complier's executable. Some of the calculator's built-in
functions are renamed to make them less cryptic, e.g. determinant
instead of DET and transpose instead of TRANS. The length of identifiers
in this language is only limited by common sense.</p>
<p>The complete syntax of the language is shown in Appendix I.</p>
<h3>Comments</h3>
<p>All characters on a line following and including the first @
character are ignored and treated as comments.</p>
<h3>Standard Functions</h3>
<p>The default set of built-in calculator functions supported is as
follows.</p>
<div class="columns3">
<b><u>Maths Functions</u></b>
<p>abs</p>
<p>acos</p>
<p>acosh</p>
<p>alog (10^x)</p>
<p>asin</p>
<p>asnh</p>
<p>atan</p>
<p>atnh</p>
<p>cos</p>
<p>cosh</p>
<p>exp (e^x)</p>
<p>fact (factorial)</p>
<p>frac (fractional part)</p>
<p>int (integer part)</p>
<p>ln</p>
<p>log</p>
<p>pi</p>
<p>reciprocal (1/x)</p>
<p>round</p>
<p>sin</p>
<p>sinh</p>
<p>sqr (x^2)</p>
<p>sqrt</p>
<p>tan</p>
<p>tanh</p>
<b><u>Mode Functions </u></b>
<p>degrees</p>
<p>radians</p>
<b><u>Time and Date Functions</u></b>
<p>to_hms</p>
<p>from_hms</p>
<p>time</p>
<p>date</p>
<b><u>Complex Functions</u></b>
<p>complex</p>
<p>re (real part)</p>
<p>im (imaginary part)</p>
<b><u>Matrix Functions</u></b>
<p>matrix</p>
<p>inverse</p>
<p>transpose</p>
<p>determinant</p>
<b><u>Graphics Functions</u></b>
<p>pixel</p>
<p>h_line (horizontal line)</p>
<p>v_line (vertical line)</p>
<b><u>Miscellaneous Functions</u></b>
<p>input</p>
<p>tone</p>
<p>pause</p>
<p>beep</p>
<p>random</p>
<p>seed (define new seed for random)</p>
<p>quiet</p>
</div>
<p>As mentioned previously, if your favourite built-in function is not
listed, you can probably add it by editing the “standard.ini” file
located with the compiler's executable. Each line in this file is a
comma separated sequence of columns. The first line is a heading which
describes the content of each column. This line is ignored, but must be
present. The first few lines of the file are as follows.</p>
<pre>
Function Name, Parameters, Keys, Result Size, Drop Size, Work Size
sqr          , 1         , X^2 , 1          , 0        , 0
sqrt         , 1         ,     , 1          , 0        , 0
pi           , 0         ,     , 1          , 0        , 0
exp          , 1         , E^X , 1          , 0        , 0
alog         , 1         , 10^X, 1          , 0        , 0
ln           , 1         ,     , 1          , 0        , 0
log          , 1         ,     , 1          , 0        , 0
degrees      , 0         , DEG , 0          , 0        , 0
radians      , 0         , RAD , 0          , 0        , 0
...
</pre>
<p>The first column contains the name of a function as it will be
recognised by the compiler. The second column indicates the number of
parameters the compiler will accept for that function and the third line
contains the textual representation of the keystrokes used by the
calculator for that function. If the third column is empty, the compiler
will use an uppercase version of the function name.</p>
<p>The compiler needs to know both the number of parameters required for
each function and the size of the result so that it can keep track of
the maximum number of elements on the stack. Most operations are well
behaved and remove their arguments from the stack before replacing them
with their result, e.g. the addition operator + removes two values from
the stack and replaces them with their sum. However not all functions
behave this way. The PIXEL function, for example, requires two arguments
to define the position of a pixel to draw, but leaves them on the stack
when it has finished. The “Drop Size”, column contains a value
indicating how many values are left on the stack, excluding its result,
after an operation is completed. The compiler uses this value to
generate DROP commands to clean up the excess values. Therefore the
entry for the pixel function is as follows.</p>
<pre>
pixel, 2, , 0, 2, 0
</pre>
<p>Meaning the high-level function will be called “pixel”, requires two
parameters, its keystroke text is the same as its name, but in
uppercase, and two values must be removed from the stack after its
execution.</p>
<p>The final column indicates the number of extra stack entries requires
as “workspace” for an operation. The entry for the h_line function
provides an example of this. The function draws a horizontal line on the
display. It requires only one parameter to indicate the y-coordinate of
the line, but uses the calculator's PIXEL function to do this. PIXEL
requires two parameter values, one of which is 0 in this case.
Therefore, in addition to the y-coordinate, an extra 0 has to be entered
onto the stack. The h_line function therefore has a workspace
requirement of one. The keystroke output consists of four commands which
must be output on separate lines. This is indicated by separating the
commands by “|” characters. The entry in “standard.ini” is therefore as
follows.</p>
<pre>
h_line, 1, +/-|0|PIXEL|DROPN 2, 0, 0, 1
</pre>
<h3>Accessing Calculator Variables and Functions from a
Program</h3>
<p>To access a named calculator variable use the recall function.</p>
<pre>
x = recall(“my_var”);
</pre>
<p>To store an expression in a named calculator variable use the store
statement.</p>
<pre>
store(sin(x)^2 + 3, “my_var”);
</pre>
<p>To evaluate a named calculator function use the external function.
The number of values expected on the stack by the named function must
match the number provided in the call and the named function must remove
those values and return exactly one value on the stack. Any other
disturbance of the stack may disrupt subsequent execution of the
program.</p>
<pre>
c = external(“my_func”)(a + b , x^2);
</pre>
<p>To evaluate a named calculator function which does not return a
result, use the external statement. The number of values expected on the
stack by the named function must match the number provided in the call
and the named function must remove those values before it returns. Any
other disturbance of the stack may disrupt subsequent execution of the
program.</p>
<pre>
external(“action”)(3);
</pre>
<h3>Register Usage</h3>
<p>The information tab in the compiler's window will show the calculator
registers and labels used after a program has been compiled. This
information can be used to avoid conflicts with external functions. By
default, program variables are stored in numbered registers. The number
of the first register used can be set on the options tab.</p>
<p>If the “Named Registers” option is selected, the compiler will
generate keystrokes which use named registers instead of numbered ones,
e.g. RCL “00” instead RCL 00. Programs which use complex or matrix
values must be compiled with this option selected due to calculator
restrictions.</p>
<h3>Appendix I: Language Syntax</h3>
<p>The complete syntax of the language is shown below. The notation is a
form of EBNF. In this version of EBNF an item enclosed in square
brackets is optional. An item enclosed in braces may occur zero or more
times. If the item in braces is followed by a terminal symbol, that item
may occur zero or more times with the indicated terminal symbol between
occurrences, e.g. { &lt;expr&gt; “,” } defines zero or more &lt;expr&gt;
strings separated by commas.</p>
<pre class="scroll">
&lt;program&gt;               ::= &quot;program&quot; &lt;identifier&gt; &quot;(&quot; { &lt;parameter_declaration&gt; &quot;,&quot; } &quot;)&quot; &lt;block&gt;;
&lt;parameter_declaration&gt; ::= &lt;identifier&gt;;
&lt;block&gt;                 ::= &quot;{&quot; { &lt;declaration&gt; } { &lt;statement&gt; } &quot;}&quot;;
&lt;declaration&gt;           ::= &lt;function_declaration&gt;
                            |
                            &lt;variable_declaration&gt;;
&lt;function_declaration&gt;  ::= &quot;func&quot; [ &lt;void_part&gt; ] &lt;identifier&gt; &quot;(&quot; { &lt;parameter_declaration&gt; &quot;,&quot; } &quot;)&quot; &lt;block&gt;;
&lt;void_part&gt;             ::= &quot;void&quot;;
&lt;variable_declaration&gt;  ::= &quot;var&quot; &lt;identifier&gt; &quot;=&quot; &lt;expr&gt; &quot;;&quot;;
&lt;expr&gt;                  ::= &lt;term&gt; { &lt;terms&gt; };
&lt;term&gt;                  ::= (&quot;+&quot; | &quot;-&quot; | &quot;&quot;) &lt;factor&gt; { &lt;exponent&gt; } { &lt;factors&gt; };
&lt;factor&gt;                ::= &lt;integer_factor&gt;
                            |
                            &lt;real_factor&gt;
                            |
                            &lt;not_factor&gt;
                            |
                            &lt;recall_factor&gt;
                            |
                            &lt;matrix_factor&gt;
                            |
                            &lt;external_factor&gt;
                            |
                            &lt;sub_expr_factor&gt;
                            |
                            &lt;id_factor&gt;;
&lt;integer_factor&gt;        ::= &lt;number&gt;;
&lt;real_factor&gt;           ::= &lt;real number&gt;;
&lt;not_factor&gt;            ::= &quot;!&quot; &lt;factor&gt;;
&lt;recall_factor&gt;         ::= &quot;recall&quot; &quot;(&quot; &lt;string_literal&gt; &quot;)&quot;;
&lt;matrix_factor&gt;         ::= &quot;matrix&quot; &quot;(&quot; { &lt;maxrix_row&gt; &quot;,&quot; } &quot;)&quot;;
&lt;maxrix_row&gt;            ::= &quot;[&quot; { &lt;expr&gt; &quot;,&quot; } &quot;]&quot;;
&lt;external_factor&gt;       ::= &quot;external&quot; &quot;(&quot; &lt;string_literal&gt; &quot;)&quot; &lt;parameters&gt;;
&lt;parameters&gt;            ::= &quot;(&quot; { &lt;expr&gt; &quot;,&quot; } &quot;)&quot;;
&lt;sub_expr_factor&gt;       ::= &quot;(&quot; &lt;expr&gt; &quot;)&quot;;
&lt;id_factor&gt;             ::= &lt;identifier&gt; [ &lt;parameters&gt; ];
&lt;exponent&gt;              ::= &quot;^&quot; &lt;factor&gt;;
&lt;factors&gt;               ::= (&quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&amp;&quot;) (&quot;+&quot; | &quot;-&quot; | &quot;&quot;) &lt;factor&gt; { &lt;exponent&gt; };
&lt;terms&gt;                 ::= (&quot;+&quot; | &quot;-&quot; | &quot;|&quot; | &quot;xor&quot;) &lt;term&gt;;
&lt;statement&gt;             ::= &lt;stop_statement&gt;
                            |
                            &lt;prompt_statement&gt;
                            |
                            &lt;store_statement&gt;
                            |
                            &lt;input_statement&gt;
                            |
                            &lt;view_statement&gt;
                            |
                            &lt;external_statement&gt;
                            |
                            &lt;id_statement&gt;
                            |
                            &lt;for_statement&gt;
                            |
                            &lt;while_statement&gt;
                            |
                            &lt;if_statement&gt;
                            |
                            &lt;block_statement&gt;
                            |
                            &lt;return_statement&gt;
                            |
                            &lt;skip_statement&gt;;
&lt;stop_statement&gt;        ::= &quot;stop&quot; &quot;;&quot;;
&lt;prompt_statement&gt;      ::= &quot;prompt&quot; &quot;(&quot; &lt;string_literal&gt; &quot;)&quot; &quot;;&quot;;
&lt;store_statement&gt;       ::= &quot;store&quot; &quot;(&quot; &lt;expr&gt; &quot;,&quot; &lt;string_literal&gt; &quot;)&quot; &quot;;&quot;;
&lt;input_statement&gt;       ::= &quot;input&quot; &quot;(&quot; &lt;identifier&gt; &quot;)&quot; &quot;;&quot;;
&lt;view_statement&gt;        ::= &quot;view&quot; &quot;(&quot; &lt;identifier&gt; &quot;)&quot; &quot;;&quot;;
&lt;external_statement&gt;    ::= &quot;external&quot; &quot;(&quot; &lt;string_literal&gt; &quot;)&quot; &lt;parameters&gt; &quot;;&quot;;
&lt;id_statement&gt;          ::= &lt;identifier&gt; &lt;assignment_or_call&gt; &quot;;&quot;;
&lt;assignment_or_call&gt;    ::= &lt;assignment&gt;
                            |
                            &lt;call&gt;;
&lt;assignment&gt;            ::= &quot;=&quot; &lt;expr&gt;;
&lt;call&gt;                  ::= &lt;parameters&gt;;
&lt;for_statement&gt;         ::= &quot;for&quot; &lt;identifier&gt; &quot;=&quot; &lt;expr&gt; &quot;to&quot; &lt;expr&gt; [ &lt;for_step&gt; ] &quot;do&quot; &lt;statement&gt;;
&lt;for_step&gt;              ::= &quot;step&quot; &lt;expr&gt;;
&lt;while_statement&gt;       ::= &quot;while&quot; &quot;(&quot; &lt;comparison&gt; &quot;)&quot; &lt;statement&gt;;
&lt;comparison&gt;            ::= &lt;expr&gt; (&quot;=&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot;) &lt;expr&gt;;
&lt;if_statement&gt;          ::= &quot;if&quot; &quot;(&quot; &lt;comparison&gt; &quot;)&quot; &lt;statement&gt; [ &lt;else_statement&gt; ];
&lt;else_statement&gt;        ::= &quot;else&quot; &lt;statement&gt;;
&lt;block_statement&gt;       ::= &lt;block&gt;;
&lt;return_statement&gt;      ::= &quot;return&quot; &lt;expr&gt; &quot;;&quot;;
&lt;skip_statement&gt;        ::= &quot;skip&quot; &quot;;&quot;;
</pre>
<h3>Appendix II: System Requirements</h3>
<p>The executables require .Net Framework 3.5 to be installed. Your
system should prompt you and offer to do this if it is not present.</p>
<p>The sources are backwards compatible with VS 2008 and later versions
should be able to convert them.</p>
<p>The implementation of the compiler is described <a href='https://github.com/jackbrennan-creator/DM42-Calculator-Compiler'>here</a>.</p>
</body>
</html>
